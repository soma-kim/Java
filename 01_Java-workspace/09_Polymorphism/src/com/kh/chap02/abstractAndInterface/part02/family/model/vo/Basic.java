package com.kh.chap02.abstractAndInterface.part02.family.model.vo;

// interface: 추상 클래스인데 종특인 애
public interface Basic {
	
	/*
	 * *인터페이스
	 * 모든 필드가 상수 필드이고, 모든 메소드가 추상 메소드인 일종의 추상 클래스
	 * 
	 * [ 표현법 ] 
	 * public interface 인터페이스명 {
	 * 
	 * }
	 * 
	 * 		// 필드부: 상수 필드만 정의되어야 함
	 * 		
	 * 		// 생성자부: 추상 클래스는 어차피 객체 생성이 불가하므로 생성자부 생략 
	 * 		
	 * 		// 메소드부: 추상 메소드들만 있어야 함
	 * 
	 * - 인퍼테이스에서 모든 필드는 무조건 상수 필드
	 * - 인터페이스에서 모든 메소드는 무조건 추상 메소드
	 * - 무조건 구현해야 될 것들이 있을 때 인터페이스를 만들어서 상속하게 됨
	 * - 추상 클래스와 다르게 좀 더 강한 규칙성, 강제성을 제공하는 게 인터페이스
	 * 
	 *  *추상 클래스와 인터페이스의 비교
	 *  1. 공통점
	 *  - 객체 생성은 안 되나 다형성은 적용 가능함
	 *  - 상속(구현) 하는 클래스에 추상 메소드를 오버라이딩 하도록 강제함
	 *  
	 *  2. 차이점
	 *  - 추상클래스는 클래스 내에 자유롭게 필드, 메소드를 생성 가능하고
	 *    추상 메소드가 포함되었거나 포함되지 않더라도 abstract class로 생성하면 추상 클래스로 정의됨
	 *    인터페이스는 인터페이스 내에 상수 필드, 추상 메소드로만 구성되어야 함
	 *  - 존재하는 목적이 다름
	 *    추상 클래스: 공통적인 코드를 모아두고 더 가져다가 기능을 "확장"시켜서 쓰겠다 (클래스명 extends 부모클래스명)
	 *    인터페이스: 클래스의 기능 구현을 강제하기 위해서 가져다 쓰겠다 == 적어도 해당 메소드들은 다 가지고 있어야 함
	 *    													(클래스명 implements 인터페이스명)
	 *    => 즉, 구현을 강제함으로써 구현 객체들의 같은 동작을 보장할 수 있음
	 *    
	 * 3. extends 와 implements
	 * - 클래스 간의 상속관계일 경우: 자식클래스명 extends 부모클래스명 (다중상속 불가)
	 * - 클래스와 인터페이스 간의 구현관계일 경우: 클래스명 implements 인터페이스명, 인터페이스명2, ... (다중구현 가능)
	 * - 인터페이스와 인터페이스 간의 상속관계일 경우: 자식인터페이스명 extends 부모인터페이스명, 부모인터페이스명2, ... (다중구현 가능)
	 */
	
	// 필드부: 상수 필드만 선언 가능
	/* public static */ final int NUM = 10;
	// 인터페이스에는 상수 필드만 정의할 수 있기 때문에
	// public static final은 생략 가능함 (묵시적으로 쓰지 않음)
	// private int a; // 일반 필드 선언이 불가
	
	// 메소드부: 추상 메소드만 선언 가능
	/* public static */ void sleep();
	/* public static */ void eat();
	// 인터페이스에는 추상 메소드만 정의할 수 있기 때문에
	// 앞의 public abstract 은 생략 가능함 (묵시적으로 쓰지 않음)

}
